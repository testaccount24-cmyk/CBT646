/* REXX ***************************************************************/
/***                                                                  */
/*** Needs:                                                           */
/***   Make sure it will still run on CMS                             */
/***   Generate correct initialization code for PDF edit macros       */
/***   Remove any TRIBLET-specific stuff                              */
/***   IF A = THEN NOP does not translate correctly.                  */
/***   TC09.2                                                         */
/***   IF A=B THEN ELSE should generate a NOP ELSE clause. (TC09.3)   */
/***   Message IDs                                                    */
/***   Use MSG for CONTROL LIST/NOLIST                                */
/***   Update help text                                               */
/***                                                                  */
/***                                                                  */
/***                                                                  */
/***                                                                  */
/*** Fixed Problems:                                                  */
/***   SET X = TOM, &NRSTR(&MIDDLE), AND HARRY                        */
/***     translates to:                                               */
/***       x = "TOM," middle, "AND HARRY"                             */
/***   Optimized parsing when only postional parms, or no parms       */
/***     at all.                                                      */
/***   Correct use of Clist continuation.                             */
/***   ISPEXEC TBCLOSE TABLE LIBRARY(&LIBNAME) translates to          */
/***     Address ISPEXEC "TBCLOSE TABLE LIBRARY("libname)             */
/***     Note the incorrect handling of the close paren, but then     */
/***     we also have to handle close parens in arithmetic            */
/***     expressions.                                                 */
/***   ALLOC FILE(FOO) DA(*) REUSE                                    */
/***     translates to                                                */
/***   "ALLOC FILE(FOO) DA("*) "REUSE"                                */
/***   Support for SYSTWOBYTE function                                */
/***   SET FOO = (no right side) is a valid CLIST stmt.  See TC06.    */
/***   SAA REXX conformance                                           */
/***   GOODREXX                                                       */
/***   Some comments get closed with star slash star. (could not      */
/***     reproduce)                                                   */
/***   Support for SYSCLENGTH function                                */
/***   Support for SYSCSUBSTR function                                */
/***   Support for converting FB 80 execs                             */
/***   This exec can now be put in an FB 80 exec file                 */
/***                                                                  */
/*** 'Post Chuck' changes :                                           */
/***   14/12/2001 - CHG0001                                           */
/***   Correct 'Call Putudndent' to 'Call Put_indent'                 */
/***   thomas.cothmann@ppi.de                                         */
/***                                                                  */
/***                                                                  */
/*** CLS2REXX - An ISPF/PDF edit macro to assist with conversion of   */
/***           CLISTs to REXX.  See help text below for details.      */
/***                                                                  */
/*** This macro will run under both TSO and CMS.                      */
/***                                                                  */
/*** Author: Chuck Tribolet, TRIBLET at STLMVS1                       */
/***                                                                  */
/**********************************************************************/
Signal On NoValue
Parse source opsys . cmd_name .
If opsys = "TSO"
  Then
    Do
    ADDRESS ISREDIT
    ISREDIT = ""
    End
  Else
    ISREDIT = "ISREDIT"
ISREDIT "MACRO (PARM)"
parm = strip(translate(parm))
If parm = "?"
  Then
    Do
    Call Help
    Exit 0
    End
test_mode = 0
Select
  When parm = "TEST"
    Then
      test_mode = 1
  When parm = "TRACE"
    Then
      test_mode = 2
  When parm = ""
    Then
      Nop
  Otherwise
      Do
      zedsmsg = "Invalid parm"
      zedlmsg = '"'parm'" is an invalid parameter.'
      ADDRESS  ISPEXEC "SETMSG MSG(ISRZ001)"
      Exit 8
      End
  End
if test_mode ¬= 0
  then
    Say 'Test_mode =' Test_mode
If opsys = "TSO" & userid() = "TRIBLET"
  Then
    Do
    ISREDIT "(DSNAME) = DATASET"
    If dsname = "TRIBLET.CLS2REXX.TESTCASE.CLIST",
      |dsname = "TRIBLET.CLS2REXX.TESTCASE.CLISTFB"
      Then
        Do
        ISREDIT "DEFINE CLS2FILE CMD MACRO"
        ISREDIT "DEFINE SAVE DISABLED"
        ISREDIT "DEFINE END ALIAS CLS2FILE"
        End
    End
ISREDIT "(FIRSTLIN) = LINE 1"
If left(word(firstlin,1),2) = "/*",
  & pos("REXX",firstlin) ¬= 0
  Then
    Do
    zedsmsg = "Already REXXified"
    zedlmsg = "The current file is already a REXX exec."
    ADDRESS  ISPEXEC "SETMSG MSG(ISRZ001)"
    Exit 4
    End
ISREDIT "(NUMLINES) = LINENUM .ZLAST"
ISREDIT "(LRECL) = LRECL"
ISREDIT "(RECFM) = RECFM"
If recfm = "F",
  & lrecl = 80,
  Then
    lrecl = lrecl - 8
token_offset = 0
curr_token = ""
next_token = ""
curr_char  = ""
next_char  = ""
curr_stmt = ""
new_exp   = ""
label_list = ""
verb = ""
output_line.1 = ""
output_line_type.1 = ""
output_recd = ""
pdf_edit_macro_found = 0
control_stmt_used = 0
control_list_stmt_used = 0
first_proc_stmt_found = 0
input_line_number = 0
output_line_number = 0

must_define.sysdval = 0
must_define.sysprompt = 0
must_define.syssymlist = 0
must_define.sysconlist = 0
must_define.syslist = 0
must_define.sysasis = 0
must_define.sysmsg = 0
must_define.sysflush = 0
must_define.eval = 0
must_define.syslc = 0
must_define.substrc = 0
must_define.sysnsub = 0
must_define.sysouttrap = 0
must_define.sysoutline = 0
indent = 0
Call Get_Stmt
Do while input_line_number <= numlines
  Call Parse_Stmt
  End
indent = 0
Call Put_Stmt "Exit 0"
If control_list_stmt_used
  Then
    Do
    Call Put_Stmt " "
    Call Put_Stmt "check_control_options:"
    Call Put_Stmt "Select"
    Call Put_Stmt "  When syssymlist = 'ON' & sysconlist= 'OFF'"
    Call Put_Stmt "    Then"
    Call Put_Stmt "      control_options_value = 'a'"
    Call Put_Stmt "  When sysconlist = 'ON'"
    Call Put_Stmt "    Then"
    Call Put_Stmt "      control_options_value = 'r'"
    Call Put_Stmt "  When syslist = 'ON'"
    Call Put_Stmt "    Then"
    Call Put_Stmt "      control_options_value = 'c'"
    Call Put_Stmt "  Otherwise"
    Call Put_Stmt "      control_options_value = 'o'"
    Call Put_Stmt "  End"
    Call Put_Stmt "  Return 0"
    End
ISREDIT "CAPS OFF"
ISREDIT "NUMBER OFF"
ISREDIT "DELETE .ZFIRST .ZLAST"
ISREDIT 'LINE_AFTER 0 = "/* REXX */"'
If opsys = 'TSO'
  Then
    Address TSO "NEWSTACK"
  Else
    Address CMS "MAKEBUF"
already_queued = queued()
Queue "/* "cmd_name"ed by" userid() "on" date() "at" time() " */"
Queue "Signal On NoValue"
Queue "Parse source opsys . exec_name ."
If pdf_edit_macro_found
  Then
    Do
    Queue "If opsys = 'TSO'"
    Queue "  Then"
    Queue "    Do"
    Queue "    Address ISREDIT"
    Queue "    ISREDIT = ''"
    Queue "    End"
    Queue "  Else"
    Queue "    ISREDIT = 'ISREDIT'"
    End
If must_define.sysdval
  Then
    Queue "sysdval = ''"
If must_define.sysprompt
  Then
    Queue "sysprompt = 'OFF'"
If must_define.syssymlist,
  | control_list_stmt_used
  Then
    Queue "syssymlist = 'OFF'"
If must_define.sysconlist,
  | control_list_stmt_used
  Then
    Queue "sysconlist = 'OFF'"
If must_define.syslist,
  | control_list_stmt_used
  Then
    Queue "syslist = 'OFF'"
If must_define.sysasis
  Then
    Queue "sysasis = 'OFF'"
If must_define.sysmsg
  Then
    Queue "sysmsg = 'ON'"
If must_define.sysflush
  Then
    Queue "sysflush = 'ON'"
If control_stmt_used
  Then
    Queue "control_options_value = 'o'"
Queue " "
Queue " "
Call Append_Stack
If opsys = 'TSO'
  Then
    Address TSO "DELSTACK"
  Else
    Address CMS "DROPBUF"
Do i = 1 to output_line_number
  thisline = strip(output_line.i,"t")
  If length(thisline) = 0
    Then
      ThisLine = " "
  ISREDIT "(LAST) = LINENUM .ZLAST"
  If test_mode >= 1
    Then
      Say "LineBefor" last output_line_type.i '"'ThisLine'"'
  ISREDIT "LINE_BEFORE .ZLAST =" output_line_type.i "(THISLINE)"
  End
If opsys = 'TSO'
  Then
    Address TSO "NEWSTACK"
  Else
    Address CMS "MAKEBUF"
already_queued = queued()
If must_define.eval
  Then
    Do
    Queue " "
    Queue "eval: Procedure"
    Queue "  Return arg(1)"
    End
If must_define.syslc
  Then
    Do
    Queue " "
    Queue "syslc: Procedure"
    Queue "  Return translate(arg(1),,"
    Queue "       'abcdefghijklmnopqrstuvwxyz',,"
    Queue "       'ABCDEFGHIJKLMNOPQRSTUVWXYZ')"
    End
If must_define.substrc
  Then
    Do
    Queue " "
    Queue "substrc: Procedure"
    Queue " If arg(3) = ''"
    Queue "   Then"
    Queue "     Do"
    Queue "     s = Arg(1)"
    Queue "     l = 1"
    Queue "     v = arg(2)"
    Queue "     End"
    Queue "   Else"
    Queue "     Do"
    Queue "     s = arg(1)"
    Queue "     l = arg(2)-arg(1)+1"
    Queue "     v = arg(3)"
    Queue "     End"
    Queue "  Return substr(v,s,l)"
    End
If must_define.sysnsub
  Then
    Do
    Queue " "
    Queue "sysnsub: Procedure"
    Queue " return arg(1)"
    End
If must_define.sysouttrap
  Then
    Do
    Queue " "
    Queue "sysouttrap: /*Procedure*/"
    Queue "  Interpret 'sysouttrap_Result = 'OutTrap()'MAX'"
    Queue "  Return sysouttrap_Result"
    End
If must_define.sysoutline
  Then
    Do
    Queue " "
    Queue "sysoutline: /*Procedure*/"
    Queue "  sysouttrap_Index = arg(1)"
    Queue "  Interpret 'sysouttrap_Result = 'OutTrap()sysouttrap_Index"
    Queue "  Return sysouttrap_Result"
    End
Queue " "
Call Append_Stack
If opsys = 'TSO'
  Then
    Address TSO "DELSTACK"
  Else
    Address CMS "DROPBUF"
ISREDIT "LEFT MAX"
ISREDIT "UP MAX"
Exit 0
/*1*/
/**********************************************************************/
/*** Parse_Stmt:                                                    ***/
/***   Subroutine to parse a single CLIST statement, and translate  ***/
/***   it to REXX.                                                  ***/
/***                                                                ***/
/***   Parameters:                                                  ***/
/***     None.                                                      ***/
/***                                                                ***/
/**********************************************************************/

Parse_Stmt: Procedure expose curr_token,
                             curr_token_type,
                             next_token,
                             next_token_type,
                             token_offset,
                             first_token,
                             curr_stmt,
                             curr_char,
                             next_char,
                             test_mode,
                             expr_depth,
                             numlines,
                             input_line_number,
                             cmd_name,
                             output_recd,
                             output_line_type.,
                             output_line.,
                             output_line_number,
                             quote_mode,
                             must_define.,
                             new_exp,
                             verb,
                             lrecl,
                             label_list,
                             pdf_edit_macro_found,
                             control_stmt_used,
                             control_list_stmt_used,
                             first_proc_stmt_found,
                             indent,
                             isredit
  expr_depth = 0
  If input_line_number > numlines
    Then
      Leave
  If test_mode >= 2
    Then
      Say 'Parse_Stmt' verb
  Select

    When verb = "PROC"
      Then
        Do
        If first_proc_stmt_found
          Then
            Do
            indent = indent + 2
            Call Put_Stmt "Procedure"
            End
        tsoproc_parms = "PROC"
        Do while curr_token_type ¬= "<eos>"
          Call Get_Token
          Select
            When curr_token_type = "<comment>"
              Then
                Call Put_Stmt curr_token
            When curr_token_type = "<eos>"
              Then
                Nop
            Otherwise
                tsoproc_parms = tsoproc_parms||curr_token
            End
          End
        Select
          When words(tsoproc_parms) <= 2
            Then
              Nop
          When datatype(word(tsoproc_parms,2)) ¬= "NUM"
            Then
              Do
              Call Put_Msg "Warning:" verb "at input line",
                   input_line_number "has non-numeric count."
              End
          When word(tsoproc_parms,2) = words(tsoproc_parms)-2
            Then
              Do
              Call Put_Stmt "Parse upper arg argument_list"
              Call Put_Stmt "If words(argument_list) >",
                            word(tsoproc_parms,2)
              Call Put_Stmt "  Then"
              Call Put_Stmt "    Do"
              Call Put_Stmt "    Say 'Extraneous parm value",
                                   """'subword(argument_list,",
                                   word(tsoproc_parms,2)+1")'""",
                                   "ignored.'"
              Call Put_Stmt "    End"
              Call Put_Stmt "If words(argument_list) <",
                            word(tsoproc_parms,2)
              Call Put_Stmt "  Then"
              Call Put_Stmt "    Do"
              Call Put_Stmt "    Say 'Positional Parms'",
                                   "subword('"tsoproc_parms"',",
                                   "words(argument_list)+3) 'omitted.'"
              Call Put_Stmt "    Exit"
              Call Put_Stmt "    End"
              Call Put_Stmt "Parse Var argument_list",
                            subword(tsoproc_parms,3) "."
              End
          Otherwise
              Do
              Call Put_Stmt "Parse upper arg argument_list"
              Call Put_Stmt "Call TSOPROC argument_list,,
                            '"tsoproc_parms"'"
              Call Put_Stmt "Interpret Result"
              Call Put_Stmt "If RC ¬= 0"
              Call Put_Stmt "  Then"
              Call Put_Stmt "    Do"
              Call Put_Stmt "    Say tsoproc_msg"
              Call Put_Stmt "    Exit RC"
              Call Put_Stmt "    End"
              End
          End
        Call Get_Stmt
        If first_proc_stmt_found
          Then
            Do
            Do while verb ¬= "END",
              & input_line_number <= numlines
              Call Parse_Stmt
              End
            Call Put_indent                 /* CHG-0001 */
            Call Put_Token "Return"
            Call Get_Token
            Call Parse_Expression
            Call Put_Line
            Call Get_Stmt
            indent = indent - 2
            End
        first_proc_stmt_found = 1
        End

    When verb = "ATTN"
      Then
        Do
        Call Put_Msg "Warning:" verb "at input line",
             input_line_number "not translateable by" cmd_name"."
        Call Put_Token "/*!"
        Call Put_Indent
        Call Put_Token verb||" "
        Call Get_Token
        Call Parse_Expression
        Call Put_Token "*/"
        Call Put_Line
        Call Get_Stmt
        End

    When verb = "CLOSFILE"
      Then
        Do
        Call Get_Token
        Call Get_Token
        Call Put_Indent
        Call Put_Token 'Address TSO "EXECIO * DISKR '
        If curr_token_type = "<variable>"
          Then
            Call Put_Token '"'substr(curr_token,2)'"'
          Else
            Call Put_Token curr_token
        Call Put_Token ' (FINIS"'
        Call Put_Line
        Call Get_Token
        Call Get_Stmt
        End

    When verb = "CONTROL"
      Then
        Do
        control_stmt_used = 1
        Call Get_NonBlank_Token
        list_option_set = 0
        Call Put_Stmt "Do"
        Do while curr_token_type ¬= "<eos>"
          Select
            When curr_token = "LIST"
              Then
                Do
                Call Put_Stmt "Syslist = 'ON'"
                list_option_set = 1
                End
            When curr_token = "NOLIST"
              Then
                Do
                Call Put_Stmt "Syslist = 'OFF'"
                list_option_set = 1
                End
            When curr_token = "CONLIST"
              Then
                Do
                Call Put_Stmt "sysconlist = 'ON'"
                list_option_set = 1
                End
            When curr_token = "NOCONLIST"
              Then
                Do
                Call Put_Stmt "sysconlist = 'OFF'"
                list_option_set = 1
                End
            When curr_token = "SYMLIST"
              Then
                Do
                Call Put_Stmt "syssymlist = 'ON'"
                list_option_set = 1
                End
            When curr_token = "NOSYMLIST"
              Then
                Do
                Call Put_Stmt "syssymlist = 'OFF'"
                list_option_set = 1
                End
            When curr_token = "PROMPT"
              Then
                Do
                Call Put_Stmt "Call Prompt 'ON'"
                Call Put_Stmt "sysprompt = 'ON'"
                must_define.sysprompt = 1
                End
            When curr_token = "NOPROMPT"
              Then
                Do
                Call Put_Stmt "Call Prompt 'OFF'"
                Call Put_Stmt "sysprompt = 'OFF'"
                must_define.sysprompt = 1
                End
            When curr_token = "MSG"
              Then
                Do
                Call Put_Stmt "Call OutTrap 'OFF'"
                Call Put_Stmt "sysmsg = 'ON'"
                must_define.sysmsg = 1
                End
            When curr_token = "NOMSG"
              Then
                Do
                Call Put_Stmt "Call OutTrap 'outtrap.'"
                Call Put_Stmt "sysmsg = 'OFF'"
                must_define.sysmsg = 1
                End
            When curr_token = "FLUSH"
              Then
                Do
                Call Put_Msg "Warning: CONTROL" curr_token,
                    "at input line" input_line_number,
                    "not translateable by" cmd_name"."
                Call Put_Stmt "sysflush = 'ON' /*!*/"
                must_define.sysflush = 1
                End
            When curr_token = "NOFLUSH"
              Then
                Do
                Call Put_Msg "Warning: CONTROL" curr_token,
                     "at input line" input_line_number,
                     "not translateable by" cmd_name"."
                Call Put_Stmt "sysflush = 'OFF' /*!*/"
                must_define.sysflush = 1
                End
            When curr_token = "CAPS"
              Then
                Do
                Call Put_Msg "Warning: CONTROL" curr_token,
                     "at input line" input_line_number,
                     "not translateable by" cmd_name"."
                Call Put_Stmt "sysasis = 'OFF' /*!*/"
                must_define.sysasis = 1
                End
            When curr_token = "NOCAPS"
              Then
                Do
                Call Put_Stmt "sysasis = 'ON'"
                must_define.sysasis = 1
                End
            When curr_token = "ASIS"
              Then
                Do
                Call Put_Stmt "sysasis = 'ON'"
                must_define.sysasis = 1
                End
            When curr_token = "MAIN"
              Then
                Do
                Call Put_Msg "Warning: CONTROL" curr_token,
                    "at input line" input_line_number,
                    "not translateable by" cmd_name"."
                Call Put_Stmt "/*!CONTROL MAIN*/"
                End
            When curr_token = "END"
              Then
                Do
                Call Put_Msg "Warning: CONTROL" curr_token,
                    "at input line" input_line_number,
                    "not translateable by" cmd_name"."
                Call Put_Stmt "/*!CONTROL END*/"
                End
            Otherwise
                Call Put_Msg "Warning: CONTROL" curr_token,
                             "at input line",
                     input_line_number "not recognized by" cmd_name"."
            End
          Call Get_NonBlank_Token
          End
        If list_option_set
          Then
            Do
            control_list_stmt_used = 1
            Call Put_Stmt "Call check_control_options"
            Call Put_Stmt "trace value control_options_value"
            End
        Call Put_Stmt "End"
        Call Get_Stmt
        End

    When verb = "DATA"
      Then
        Do
        Call Get_NonBlank_Token
        save_token = curr_token
        Call Put_Stmt "Do "
        Call Get_Stmt
        Do while verb ¬= "ENDDATA",
          & input_line_number <= numlines
          Call Put_Indent
          If save_token = "PROMPT"
            Then
              Call Put_Token "Queue '"verb" "
            Else
              Call Put_Token "Address TSO "
          Call Get_Token
          Call Parse_Expression "q"
          Call Put_Line
          Call Get_Stmt
          End
        Call Put_Indent
        Call Put_Token "End "
        Call Get_Token
        Call Parse_Expression
        Call Put_Line
        Call Get_Stmt
        End

    When verb = "DO"
      Then
        Do
        Call Put_Indent
        Call Put_Token "Do"
        Call Get_Token
        Do while curr_token_type = "<comment>",
          | curr_token_type = "<blanks>"
          Call Put_Token curr_token
          Call Get_Token
          End
        If next_token_type = "<eos>"
          Then
            Do
            Call Get_Token
            Call Parse_Expression
            Call Put_Line
            Call Get_Stmt
            Do while verb ¬= "END",
              & input_line_number <= numlines
              Call Parse_Stmt
              End
            Call Put_Indent
            Call Put_Token "End "
            Call Get_Token
            Call Parse_Expression
            Call Put_Line
            Call Get_Stmt
            End
          Else
            Do
            If  curr_token ¬= "WHILE",
              & curr_token ¬= "UNTIL",
              Then
                Do
                Call Put_Indent
                If left(curr_token,1) = "&"
                  Then
                    curr_token = substr(curr_token,2)
                Call Put_Token curr_token" "
                Call Get_Token
                Call Parse_Expression "","Do_i"
                If curr_token = "TO"
                  Then
                    Do
                    Call Put_Token "to "
                    Call Get_Token
                    Call Parse_Expression "","Do_to"
                    End
                If curr_token = "BY"
                  Then
                    Do
                    Call Put_Token "by "
                    Call Get_Token
                    Call Parse_Expression "","Do_by"
                    End
                End
            Do 2
              If  curr_token = "WHILE",
                | curr_token = "UNTIL",
                Then
                  Do
                  If curr_token = "WHILE"
                    Then
                      Call Put_Token "while "
                    Else
                      Call Put_Token "until "
                  Call Get_Token
                  Call Parse_Expression "","Do_while"
                  End
              End
            Call Put_Line
            indent = indent + 2
            Call Get_Stmt
            Do while verb ¬= "END",
              & input_line_number <= numlines
              Call Parse_Stmt
              End
            Call Put_Indent
            Call Put_Token "End "
            Call Get_Token
            Call Parse_Expression
            Call Put_Line
            Call Get_Stmt
            indent = indent - 2
            End
        End

    When verb = "END"
      Then
        Do
        if test_mode >= 2
          then
            say 'Verb=END'
        Call Put_Indent
        Call Put_Token "Exit "
        Call Get_Token
        Call Parse_Expression
        Call Put_Line
        Call Get_Stmt
        End

    When verb = "ERROR"
      Then
        Do
        Call Put_Msg "Warning:" verb "at input line",
             input_line_number "not translateable by" cmd_name"."
        Call Put_Token "/*!"
        Call Put_Indent
        Call Put_Token verb||" "
        Call Get_Token
        Call Parse_Expression
        Call Put_Token "*/"
        Call Put_Line
        Call Get_Stmt
        End

    When verb = "EXIT"
      Then
        Do
        Call Put_Indent
        Call Put_Token "Exit "
        Call Get_NonBlank_Token
        If curr_token = "CODE"
          Then
            Do
            Call Get_Token
            Call Parse_Expression
            End
        Call Put_Line
        Call Get_Stmt
        End

    When verb = "GETFILE"
      Then
        Do
        Call Get_Token
        Call Get_Token
        Call Put_Indent
        Call Put_Token 'Address TSO "EXECIO * DISKR '
        If curr_token_type = "<variable>"
          Then
            Call Put_Token '"'substr(curr_token,2)'"'
          Else
            Call Put_Token curr_token
        Call Put_Token ' (CASE M"'
        Call Put_Line
        Call Put_Indent
        If curr_token_type = "<variable>"
          Then
            Do
            Call Put_Token 'Interpret "Parse pull" '
            Call Put_Token substr(curr_token,2)
            End
          Else
            Do
            Call Put_Token "Parse pull "
            Call Put_Token curr_token
            End
        Call Put_Line
        Call Get_Token
        Call Get_Stmt
        End

    When verb = "GLOBAL"
      Then
        Do
        Call Put_Msg "Warning:" verb "at input line",
             input_line_number "not translateable by" cmd_name"."
        Call Put_Token "/*!"
        Call Put_Indent
        Call Put_Token verb||" "
        Call Get_Token
        Call Parse_Expression
        Call Put_Token "*/"
        Call Put_Line
        Call Get_Stmt
        End

    When verb = "NGLOBAL"
      Then
        Do
        Call Put_Msg "Warning:" verb "at input line",
             input_line_number "not translateable by" cmd_name"."
        Call Put_Token "/*!"
        Call Put_Indent
        Call Put_Token verb||" "
        Call Get_Token
        Call Parse_Expression
        Call Put_Token "*/"
        Call Put_Line
        Call Get_Stmt
        End

    When verb = "GOTO"
      Then
        Do
        Call Put_Msg "Warning:" verb "at input line",
             input_line_number "translated to SIGNAL."
        Call Put_Token "/*!*/"
        Call Put_Indent
        Call Put_Token "SIGNAL "
        Call Get_Token
        Do while curr_token_type ¬= "<eos>"
          If curr_token_type = "<keyword>",
            & find(label_list,curr_token) ¬= 0,
            Then
              Call Put_Msg "Warning: label" curr_token,
                           "is already defined.  SIGNAL will fail."
          Call Put_Token curr_token
          Call Get_Token
          End
        Call Put_Line
        Call Get_Stmt
        End

    When verb = "IF"
      Then
        Do
        Call Put_Indent
        Call Put_Token "If "
        Call Get_Token
        Call Parse_Expression "","If"
        Call Put_Line
        indent = indent + 2
        Call Put_Stmt "Then "
        indent = indent + 2
        Call Get_NonBlank_Token
        verb = translate(curr_token)
        Call Parse_Stmt
        indent = indent - 2
        If verb = "ELSE"
          Then
            Do
            Call Put_Stmt "Else "
            indent = indent + 2
            Call Get_NonBlank_Token
            verb = translate(curr_token)
            Call Parse_Stmt
            indent = indent - 2
            End
        indent = indent - 2
        End

    When verb = "ISPEXEC"
      Then
        Do
        Call Put_Indent
        Call Put_Token "Address ISPEXEC "
        Call Get_Token
        Call Parse_Expression "q"
        Call Put_Line
        Call Get_Stmt
        End

    When verb = "ISREDIT"
      Then
        Do
        pdf_edit_macro_found = 1
        Call Put_Indent
        Call Put_Token "ISREDIT "
        Call Get_Token
        Call Parse_Expression "q"
        Call Put_Line
        Call Get_Stmt
        End

    When verb = "LISTDSI"
      Then
        Do
        Call Put_Indent
        Call Put_Token "Call ListDSI "
        Call Get_Token
        Call Parse_Expression "q"
        Call Put_Line
        Call Get_Stmt
        End

    When verb = "OPENFILE"
      Then
        Do
        Call Put_Indent
        Call Put_Token "Nop"
        Call Put_Line
        Call Get_Stmt
        End

    When verb = "PUTFILE"
      Then
        Do
        Call Get_Token
        Call Get_Token
        Call Put_Indent
        If curr_token_type = "<variable>"
          Then
            Do
            Call Put_Token 'Interpret "queue" '
            Call Put_Token substr(curr_token,2)
            End
          Else
            Do
            Call Put_Token "queue "
            Call Put_Token curr_token
            End
        Call Put_Line
        Call Put_Indent
        Call Put_Token 'Address TSO "EXECIO * DISKW '
        If curr_token_type = "<variable>"
          Then
            Call Put_Token '"'substr(curr_token,2)'"'
          Else
            Call Put_Token curr_token
        Call Put_Token ' (CASE M"'
        Call Put_Line
        Call Get_Token
        Call Get_Stmt
        End

    When verb = "READ"
      Then
        Do
        parse_string = ""
        Do while next_token_type ¬= "<eos>"
          Call Get_NonBlank_Token
          If curr_token = ","
            Then
              parse_string = parse_string "."
            Else
              parse_string = parse_string curr_token
          End
        If parse_string ¬= ""
          Then
            Do
            Call Put_Stmt "Parse upper pull sysdval_temp"
            Call Put_Stmt "Parse var sysdval_temp"parse_string "."
            End
          Else
            Call Put_Stmt "Parse upper pull sysdval"
        must_define.sysdval = 1
        Call Get_Stmt
        End

    When verb = "READDVAL"
      Then
        Do
        parse_string = ""
        Do while next_token_type ¬= "<eos>"
          Call Get_NonBlank_Token
          If curr_token = ","
            Then
              parse_string = parse_string "."
            Else
              parse_string = parse_string curr_token
          End
        If parse_string ¬= ""
          Then
            Do
            Call Put_Stmt "Parse var sysdval"parse_string "."
            End
        must_define.sysdval = 1
        Call Get_Stmt
        End

    When verb = "RETURN"
      Then
        Do
        Call Put_Indent
        Call Put_Token "Return "
        Call Get_NonBlank_Token
        If curr_token = "CODE"
          Then
            Do
            Call Get_Token
            Call Parse_Expression
            End
        Call Put_Line
        Call Get_Stmt
        End

    When verb = "SELECT"
      Then
        Do
        Call Put_Indent
        Call Put_Token "Select "
        Call Get_Token
        Do while curr_token_type = "<comment>",
          | curr_token_type = "<blanks>"
          Call Put_Token curr_token
          Call Get_Token
          End
        Call Get_Token
        Call Parse_Expression
        Call Put_Line
        indent = indent + 2
        Call Get_Stmt
        Do while verb ¬= "END",
          & input_line_number <= numlines
          Call Parse_Stmt
          End
        Call Put_Indent
        Call Put_Token "End "
        Call Get_Token
        Call Parse_Expression
        Call Put_Line
        Call Get_Stmt
        indent = indent - 2
        End

    When verb = "SET"
      Then
        Do
        Call Get_NonBlank_Token
        If left(curr_token,1) = "&"
          Then
            curr_token = substr(curr_token,2)
        Call Put_Indent
        curr_token = translate(curr_token,,
                               "abcdefghijklmnopqrstuvwxyz",,
                               "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
        Call Put_Token curr_token||" "
        Call Get_NonBlank_Token
        Call Put_Token curr_token||" "
        If next_token_type = "<eos>"
          Then
            Do
            Call Get_NonBlank_Token
            Call Put_Token '""'
            End
          Else
            Do
            Call Get_Token
            Call Parse_Expression
            End
        Call Put_Line
        Call Get_Stmt
        End

    When verb = "SYSCALL"
      Then
        Do
        Call Get_NonBlank_Token
        Call Put_Indent
        curr_token = translate(curr_token,,
                               "abcdefghijklmnopqrstuvwxyz",,
                               "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
        Call Put_Token "Call" curr_token||" "
        Call Get_Token
        Call Parse_Expression
        Call Put_Line
        Call Get_Stmt
        End

    When verb = "SYSREF"
      Then
        Do
        Call Put_Msg "Warning:" verb "at input line",
             input_line_number "not translateable by" cmd_name"."
        Call Put_Token "/*!"
        Call Put_Indent
        Call Put_Token verb||" "
        Call Get_Token
        Call Parse_Expression
        Call Put_Token "*/"
        Call Put_Line
        Call Get_Stmt
        End

    When verb = "TERMIN"
      Then
        Do
        parse_string = ""
        Do while next_token_type ¬= "<eos>"
          Call Get_NonBlank_Token
          If curr_token = ","
            Then
              parse_string = parse_string "."
            Else
              parse_string = parse_string curr_token
          End
        Call Put_Stmt "Parse upper pull sysdval"
        Call Put_Stmt "Parse var sysdval sysdlm sysdval"
        Call Put_Stmt 'If sysdlm = ""'
        Call Put_Stmt "  Then"
        Call Put_Stmt '     sysdlm = ","'
        Call Put_Stmt 'sysdlm = find("'parse_string'",sysdlm)'
        Call Get_Stmt
        must_define.sysdval = 1
        End

    When verb = "WHEN"
      Then
        Do
        Call Put_Indent
        Call Put_Token "When "
        Call Get_Token
        Call Parse_Expression "","When"
        Call Put_Line
        indent = indent + 2
        Call Put_Stmt "Then "
        indent = indent + 2
        Call Get_NonBlank_Token
        verb = translate(curr_token)
        Call Parse_Stmt
        indent = indent - 2
        indent = indent - 2
        End

    When verb = "WRITE" | verb = "WRITENR"
      Then
        Do
        Call Put_Indent
        Call Put_Token "Say "
        Call Get_Token
        Call Parse_Expression
        Call Put_Line
        Call Get_Stmt
        End

    When curr_token_type = "<comment>"
      Then
        Do
        Call Put_Stmt curr_token
        Call Get_NonBlank_Token
        verb = translate(curr_token)
        Call Parse_Stmt
        End

    When curr_token_type = "<eos>"
      Then
        Do
        Call Get_Stmt
        End

    When verb = ""
      Then
        Do
        Call Get_Stmt
        End

    Otherwise
        Call Put_Indent
        Call Put_Token "Address TSO "
        Call Parse_Expression
        Call Put_Line
        Call Get_Stmt
    End
  Return 0
/*1*/
/**********************************************************************/
/*** Parse_Expression:                                              ***/
/***   Subroutine to parse a single CLIST expression, and translate ***/
/***   it to REXX.                                                  ***/
/***                                                                ***/
/***   Parameters:                                                  ***/
/***     1. "q" = the expression is a character expression, and     ***/
/***              its REXX equivalent should be in quotes.          ***/
/***        "nq" = the expression is not a character expression.    ***/
/***              This is the default.                              ***/
/***                                                                ***/
/***     2. ""  = the expression is the right side of an assignment ***/
/***              statement.                                        ***/
/***        "If" = the epression is part of an If statement and     ***/
/***               may be terminated by a THEN clause.              ***/
/***        "Do_i" = the expression is the starting point of a      ***/
/***               repetetive DO (DO I = <expr> TO 5) and may       ***/
/***               be terminated by a TO clause.                    ***/
/***        "Do_to" = the expression is the ending point of a       ***/
/***               repetetive DO (DO I = 1 TO <expr>) and may       ***/
/***               be terminated by a BY, WHILE, or UNTIL clause.   ***/
/***        "Do_by" = the expression is the increment of a          ***/
/***               repetetive DO (DO I = 1 TO 9 BY <expr>) and may  ***/
/***               be terminated by a WHILE or UNTIL clause.        ***/
/***        "Do_while" = the expression is the terminator (WHILE    ***/
/***               or UNTIL clause) of a repetetive DO.             ***/
/***        "When" = the expression is part of a When statement.    ***/
/***        "parm" = the expression is a function paramater and     ***/
/***               may be terminated by a comma or right            ***/
/***               parenthesis.  If this parameter is specified,    ***/
/***               a third parameter, the name of the function,     ***/
/***               is also specified.                               ***/
/***                                                                ***/
/**********************************************************************/
Parse_Expression: Procedure expose curr_token,
                             curr_token_type,
                             next_token,
                             next_token_type,
                             token_offset,
                             first_token,
                             curr_stmt,
                             curr_char,
                             next_char,
                             test_mode,
                             expr_depth,
                             numlines,
                             input_line_number,
                             cmd_name,
                             output_recd,
                             output_line_type.,
                             output_line.,
                             output_line_number,
                             quote_mode,
                             must_define.,
                             new_exp,
                             verb,
                             lrecl,
                             label_list,
                             pdf_edit_macro_found,
                             control_stmt_used,
                             control_list_stmt_used,
                             first_proc_stmt_found,
                             indent,
                             isredit
  expr_depth = expr_depth + 1
  If test_mode >= 2
    Then
      Do
      Say
      Say "Parse_Exp" copies("--",expr_depth) arg(1)"," arg(2)",",
           arg(3)"," curr_token_type", "curr_token
      End
  quote_mode = "nq"
  If arg(1) = "q"
    Then
      numeric_expression = 0
    Else
      numeric_expression = 1
  If_mode = 0
  Do_i_mode = 0
  Do_to_mode = 0
  Do_by_mode = 0
  Do_while_mode = 0
  When_mode = 0
  parm_mode = 0
  assignment_mode = 0
  Select
    When arg(2) = "If"
      Then
        If_mode = 1
    When arg(2) = "Do_i"
      Then
        Do_i_mode = 1
    When arg(2) = "Do_to"
      Then
        Do_to_mode = 1
    When arg(2) = "Do_by"
      Then
        Do_by_mode = 1
    When arg(2) = "Do_while"
      Then
        Do_while_mode = 1
    When arg(2) = "When"
      Then
        When_mode = 1
    When arg(2) = "parm"
      Then
        parm_mode = 1
    Otherwise
        assignment_mode = 1
    End
  paren_depth = 0
  If ¬parm_mode
    Then
      new_exp = ""
  token_num = 0
  Do while ¬((curr_token_type = "<eos>"),
    | (next_token_type = "<eos>" & token_num ¬= 0))
    If token_num ¬= 0
      Then
        Call Get_Token
    token_num = token_num + 1
    If ¬parm_mode
      Then
        Do while token_num = 1 & curr_token_type = "<blanks>"
          If test_mode >= 2
            Then
              Say "Skip_Term" copies("--",expr_depth),
                  format(token_num,6),
                  left(curr_token_type,16) curr_token
          Call Get_Token
          End
    If test_mode >= 2
      Then
        Say "Get_Term " copies("--",expr_depth) format(token_num,6),
            left(curr_token_type,16) curr_token
    Select
      When curr_token_type = "<comment>"
        Then
          Do
          Call End_Quote_Mode
          new_exp = new_exp||curr_token
          End
      When curr_token_type = "<integer>",
        |  curr_token_type = "<number>",
        Then
          Do
          Call Check_Concat_Needed
          new_exp = new_exp||curr_token
          End
      When curr_token_type = "<variable>"
        Then
          Do
          Call Check_Concat_Needed
          curr_token = substr(curr_token,2)
          Call End_Quote_Mode
          Select
            When curr_token = "sysdate"
              Then
                curr_token = 'date("u")'
            When curr_token = "syssdate"
              Then
                curr_token = 'date("o")'
            When curr_token = "sysjdate"
              Then
                curr_token = 'left(date("o"),2)"."date("d")'
            When curr_token = "systime"
              Then
                curr_token = "time()"
            When curr_token = "sysstime"
              Then
                curr_token = "left(time(),5)"
            When curr_token = "syslterm"
              Then
                curr_token = "SysVar('SysLTerm')"
            When curr_token = "syswterm"
              Then
                curr_token = "SysVar('SysWTerm')"
            When curr_token = "sysuid"
              Then
                curr_token = "userid()"
            When curr_token = "syspref"
              Then
                curr_token = "SysVar('SysPref')"
            When curr_token = "sysproc"
              Then
                curr_token = "SysVar('SysProc')"
            When curr_token = "syscpu"
              Then
                curr_token = "SysVar('SysCPU')"
            When curr_token = "syssrv"
              Then
                curr_token = "SysVar('SysSrv')"
            When curr_token = "sysispf"
              Then
                curr_token = "SysVar('SysISPF')"
            When curr_token = "sysracf"
              Then
                curr_token = "SysVar('SysRACF')"
            When curr_token = "syslracf"
              Then
                curr_token = "SysVar('SysLRACF')"
            When curr_token = "syshsm"
              Then
                curr_token = "SysVar('SysHSM')"
            When curr_token = "systsoe"
              Then
                curr_token = "SysVar('SysTSOE')"
            When curr_token = "sysenv"
              Then
                curr_token = "SysVar('SysEnv')"
            When curr_token = "sysscan"
              Then
                curr_token = "1"
            When curr_token = "sysicmd"
              Then
                curr_token = "SysVar('SysICmd')"
            When curr_token = "syspcmd"
              Then
                curr_token = "SysVar('SysPCmd')"
            When curr_token = "sysscmd"
              Then
                curr_token = "SysVar('SysSCmd')"
            When curr_token = "sysnest"
              Then
                curr_token = "SysVar('SysNest')"
            When curr_token = "sysprompt"
              Then
                Do
                curr_token = curr_token
                must_define.sysprompt = 1
                End
            When curr_token = "syssymlist"
              Then
                Do
                curr_token = curr_token
                must_define.syssymlist = 1
                End
            When curr_token = "sysconlist"
              Then
                Do
                curr_token = curr_token
                must_define.sysconlist = 1
                End
            When curr_token = "syslist"
              Then
                Do
                curr_token = curr_token
                must_define.syslist = 1
                End
            When curr_token = "sysasis"
              Then
                Do
                curr_token = curr_token
                must_define.sysasis = 1
                End
            When curr_token = "sysmsg"
              Then
                Do
                curr_token = curr_token
                must_define.sysmsg = 1
                End
            When curr_token = "sysflush"
              Then
                Do
                curr_token = curr_token
                must_define.sysflush = 1
                End
            When curr_token = "sysdlm"
              Then
                curr_token = curr_token
            When curr_token = "sysdval"
              Then
                Do
                curr_token = curr_token
                must_define.sysdval = 1
                End
            When curr_token = "sysouttrap"
              Then
                Do
                curr_token = "sysouttrap()"
                must_define.sysouttrap = 1
                End
            When left(curr_token,10) = "sysoutline"
              Then
                Do
                curr_token = "sysoutline()"
                must_define.sysoutline = 1
                End
            When curr_token = "lastcc"
              Then
                curr_token = "rc"
            When curr_token = "maxcc"
              Then
                Do
                Call Put_Msg "Warning: &"curr_token "at input line",
                     input_line_number "not translateable by",
                     cmd_name"."
                curr_token = "/*!*/"curr_token
                End
            When curr_token = "sysabncd"
              Then
                curr_token = curr_token
            When curr_token = "sysabnrc"
              Then
                curr_token = curr_token
            When curr_token = "syscmdrc"
              Then
                curr_token = curr_token
            /* begin parseing functions */
            When curr_token = "datatype"
              Then
                Call Parse_Function
            When curr_token = "eval"
              Then
                Do
                Call Parse_Function
                must_define.eval = 1
                End
            When curr_token = "length"
              Then
                Call Parse_Function
            When curr_token = "nrstr"
              Then
                Do
                Call Put_Msg "Warning: &"curr_token "at input line",
                     input_line_number "not translateable by",
                     cmd_name"."
                Call Parse_NOP_Function
                End
            When curr_token = "str"
              Then
                Call Parse_NOP_Function
            When curr_token = "substr"
              Then
                Do
                curr_token = "substrc"
                Call Parse_Function
                must_define.substrc = 1
                End
            When curr_token = "syscaps"
              Then
                Do
                curr_token = "translate"
                Call Parse_Function
                End
            When curr_token = "syslc"
              Then
                Do
                Call Parse_Function
                must_define.syslc = 1
                End
            When curr_token = "sysdsn"
              Then
                Call Parse_Function
            When curr_token = "sysindex"
              Then
                Do
                curr_token = "pos"
                Call Parse_Function
                End
            When curr_token = "sysnsub"
              Then
                Do
                Call Put_Msg "Warning: &"curr_token "at input line",
                     input_line_number "not translateable by",
                     cmd_name"."
                Call Parse_Function
                must_define.sysnsub = 1
                End
            When curr_token = "sysonebyte"
              Then
                Do
                curr_token = "dbtosbcs"
                Call Parse_Function
                End
            When curr_token = "systwobyte"
              Then
                Do
                curr_token = "dbtodbcs"
                Call Parse_Function
                End
            When curr_token = "sysclength"
              Then
                Do
                curr_token = "length"
                Call Parse_Function
                End
            When curr_token = "syscsubstr"
              Then
                Do
                curr_token = "substrc"
                Call Parse_Function
                must_define.substrc = 1
                End
            Otherwise
                curr_token = curr_token
            End
          new_exp = new_exp||curr_token
          End
      When curr_token_type = "<keyword>"
        Then
          Do
          Select
            When (If_mode | Do_while_mode),
              & (curr_token = "OR",
               | curr_token = "AND",
               | curr_token = "EQ",
               | curr_token = "NE",
               | curr_token = "LT",
               | curr_token = "GT",
               | curr_token = "LE",
               | curr_token = "GE",
               | curr_token = "NG",
               | curr_token = "NL"),
              Then
                Do
                Call End_Quote_Mode
                Select
                  When curr_token = "OR",
                    Then
                      curr_token = "|"
                  When curr_token = "AND",
                    Then
                      curr_token = "&"
                  When curr_token = "EQ",
                    Then
                      curr_token = "="
                  When curr_token = "NE",
                    Then
                      curr_token = "¬="
                  When curr_token = "LT",
                    Then
                      curr_token = "<"
                  When curr_token = "GT",
                    Then
                      curr_token = ">"
                  When curr_token = "LE",
                    Then
                      curr_token = "<="
                  When curr_token = "GE",
                    Then
                      curr_token = ">="
                  When curr_token = "NG",
                    Then
                      curr_token = "<="
                  When curr_token = "NL",
                    Then
                      curr_token = ">="
                  Otherwise
                      Nop
                  End
                End
            When If_mode & curr_token = "THEN"
              Then
                Leave
            When Do_i_mode & curr_token = "TO"
              Then
                Leave
            When Do_to_mode & find("BY WHILE UNTIL",curr_token) ¬= 0
              Then
                Leave
            When Do_by_mode & find("WHILE UNTIL",curr_token) ¬= 0
              Then
                Leave
            When Do_while_mode & find("WHILE UNTIL",curr_token) ¬= 0
              Then
                Leave
            Otherwise
                Call Start_Quote_Mode
                numeric_expression = 0
            End
          new_exp = new_exp||curr_token
          End
      When curr_token_type = "<blanks>"
        Then
          Do
          If parm_mode
            Then
              Do
              Call Start_Quote_Mode
              numeric_expression = 0
              End
          new_exp = new_exp||curr_token
          End
      When curr_token = ":",
        & parm_mode,
        & paren_depth = 0,
        & arg(3) = "substrc",
        Then
          Do
          Call end_quote_mode
          curr_token = ","
          curr_token_type = "<special_char>"
          Leave
          End
      When curr_token = ",",
        & parm_mode,
        & paren_depth = 0,
        Then
          Do
          Call end_quote_mode
          Leave
          End
      When curr_token = ")",
        & parm_mode,
    /*  & paren_depth <= 0, */
        Then
          Do
          Call end_quote_mode
          Leave
          End
      Otherwise
        Select
          When curr_token = "("
            Then
              Do
              If parm_mode | When_mode
                Then
                  paren_depth = paren_depth+1
              If ¬numeric_expression
                Then
                  Call Start_Quote_Mode
              End
          When curr_token = ")"
            Then
              Do
              If parm_mode
                Then
                  paren_depth = paren_depth-1
              If ¬numeric_expression
                Then
                  Call Start_Quote_Mode
              If When_mode
                Then
                  Do
                  new_exp = new_exp||curr_token
                  paren_depth = paren_depth-1
                  If paren_depth <= 0
                    Then
                      Leave
                  End
              End
          When curr_token_type = "<operator>"
            Then
              Do
              Select
                When curr_token = "/" & numeric_expression
                  Then
                    curr_token = "%"
                When Do_while_mode,
                  |If_mode,
                  |(assignment_mode,
                    & (find("= < > <= >= ¬=",curr_token) = 0)),
                  & numeric_expression
                  Then
                    Call End_Quote_Mode
                When ¬numeric_expression
                  Then
                    Call Start_Quote_mode
                Otherwise
                    Nop
                End
              End
          When curr_token_type = "<special_char>"
            Then
              Do
              Call Start_Quote_Mode
              numeric_expression = 0
              If curr_token = '"',
                Then
                  curr_token = curr_token||curr_token
              End
          Otherwise
              Do
              Call Put_Msg "Error:   "curr_token_type,
                           "at input line" input_line_number,
                           "not expected."
              Call Start_Quote_Mode
              numeric_expression = 0
              End
          End
        new_exp = new_exp||curr_token
      End
    End
  Call End_Quote_Mode
  If ¬parm_mode
    Then
      Call Put_Token new_exp
  If test_mode >= 2
    Then
      Do
      Say "End_Exp  " copies("--",expr_depth) arg(1)"," arg(2)"," arg(3)
      Say
      End
  expr_depth = expr_depth - 1
  Return 0

/*1*/
/**********************************************************************/
/*** Parse_Function:                                                ***/
/***   Subroutine to parse a single CLIST function, and translate   ***/
/***   it to REXX.                                                  ***/
/***                                                                ***/
/***   Parameters:                                                  ***/
/***     None.                                                      ***/
/***                                                                ***/
/**********************************************************************/
Parse_Function: Procedure expose curr_token,
                             curr_token_type,
                             next_token,
                             next_token_type,
                             token_offset,
                             first_token,
                             curr_stmt,
                             curr_char,
                             next_char,
                             test_mode,
                             expr_depth,
                             numlines,
                             input_line_number,
                             cmd_name,
                             output_recd,
                             output_line_type.,
                             output_line.,
                             output_line_number,
                             quote_mode,
                             must_define.,
                             new_exp,
                             verb,
                             lrecl,
                             label_list,
                             pdf_edit_macro_found,
                             control_stmt_used,
                             control_list_stmt_used,
                             first_proc_stmt_found,
                             indent,
                             isredit
  function_name = curr_token
  new_exp = new_exp||curr_token
  Call Get_Token
  new_exp = new_exp||curr_token
  Do forever
    Call Get_Token
    Call Parse_Expression "","parm",function_name
    new_exp = new_exp||curr_token
    If curr_token = ")"
      Then
        Do
        curr_token = ""
        curr_token_type = "<blanks>"
        Leave
        End
    End
  Return 0

/*1*/
/**********************************************************************/
/*** Parse_NOP_Function:                                            ***/
/***   Subroutine to parse a CLIST functions that don't Do anything ***/
/***   in the REXX world (like &STR), and ignore it.                ***/
/***                                                                ***/
/***   Parameters:                                                  ***/
/***     None.                                                      ***/
/***                                                                ***/
/**********************************************************************/
Parse_NOP_Function: Procedure expose curr_token,
                             curr_token_type,
                             next_token,
                             next_token_type,
                             token_offset,
                             first_token,
                             curr_stmt,
                             curr_char,
                             next_char,
                             test_mode,
                             expr_depth,
                             numlines,
                             input_line_number,
                             cmd_name,
                             output_recd,
                             output_line_type.,
                             output_line.,
                             output_line_number,
                             quote_mode,
                             must_define.,
                             new_exp,
                             verb,
                             lrecl,
                             label_list,
                             pdf_edit_macro_found,
                             control_stmt_used,
                             control_list_stmt_used,
                             first_proc_stmt_found,
                             indent,
                             isredit
  function_name = curr_token
  Call Get_Token
  If curr_char ¬= ")"
    Then
      Do
      Call Get_Token
      Call Parse_Expression "q","parm",function_name
      End
    Else
      Do
      Call Get_Token
      Call Start_Quote_Mode
      End
  curr_token = ""
  curr_token_type = "<blanks>"
  Return 0


/*1*/
/**********************************************************************/
/*** Get_Char:                                                      ***/
/***   Subroutine to get one character from the input stream.       ***/
/***                                                                ***/
/***   Parameters:                                                  ***/
/***     None.                                                      ***/
/***                                                                ***/
/**********************************************************************/
Get_Char:
  token_offset = token_offset + 1
  If token_offset > length(curr_stmt)
    Then
      curr_char = ";"
    Else
      curr_char = substr(curr_stmt,token_offset,1)
  Return 0


/*1*/
/**********************************************************************/
/*** Get_NonBlank_Token:                                            ***/
/***   Subroutine to get one non-blank token from the input stream. ***/
/***                                                                ***/
/***   Parameters:                                                  ***/
/***     None.                                                      ***/
/***                                                                ***/
/**********************************************************************/
Get_NonBlank_Token:
  Call Get_Token
  Do while curr_token_type = "<blanks>"
    Call Get_Token
    End
  Return 0


/*1*/
/**********************************************************************/
/*** Get_Token:                                                     ***/
/***   Subroutine to get one token from the input stream.           ***/
/***   The token may be blank.                                      ***/
/***                                                                ***/
/***   Parameters:                                                  ***/
/***     None.                                                      ***/
/***                                                                ***/
/**********************************************************************/
Get_Token:
  If token_offset = 0
    Then
      Do
      Call Get_Char
      End
  If token_offset > length(curr_stmt)
    Then
      Do
      curr_token_type = "<eos>"
      next_token_type = "<eos>"
      curr_token = ";"
      next_token = ";"
      Return 0
      End
  curr_token = ""
  curr_token_type = "<?>"
  Select
    When ("0" <= curr_char & curr_char <= "9"),
      Then
        Do
        curr_token_type = "<integer>"
        Do while ("0" <= curr_char & curr_char <= "9")
          curr_token = curr_token||curr_char
          Call Get_Char
          End
        If curr_char = "."
          Then
            Do
            curr_token_type = "<number>"
            curr_token = curr_token||curr_char
            Call Get_Char
            Do while ("0" <= curr_char & curr_char <= "9")
              curr_token = curr_token||curr_char
              Call Get_Char
              End
            End
        End
    When ("A" <= curr_char & curr_char <= "I"),
      |  ("J" <= curr_char & curr_char <= "R"),
      |  ("S" <= curr_char & curr_char <= "Z"),
      |  ("a" <= curr_char & curr_char <= "i"),
      |  ("j" <= curr_char & curr_char <= "r"),
      |  ("s" <= curr_char & curr_char <= "z"),
      |  curr_char = "%",
      |  curr_char = "$",
      |  curr_char = "#",
      Then
        Do
        curr_token_type = "<keyword>"
        Do while ("A" <= curr_char & curr_char <= "I"),
               | ("J" <= curr_char & curr_char <= "R"),
               | ("S" <= curr_char & curr_char <= "Z"),
               | ("a" <= curr_char & curr_char <= "i"),
               | ("j" <= curr_char & curr_char <= "r"),
               | ("s" <= curr_char & curr_char <= "z"),
               | ("0" <= curr_char & curr_char <= "9"),
               | curr_char = "_",
               | curr_char = "%",
               | curr_char = "$",
               | curr_char = "#"
          curr_token = curr_token||curr_char
          Call Get_Char
          End
        If curr_char = ":" & first_token
          Then
            Do
            curr_token_type = "<label>"
            curr_token = curr_token||curr_char
            Call Get_Char
            End
        End
    When curr_char = "&"
      Then
        Do
        curr_token_type = "<variable>"
        curr_token = curr_token||curr_char
        Call Get_Char
        If curr_char = "&"
          Then
            Do
            curr_token_type = "<operator>"
            Call Get_Char
            End
          Else
            Do
            Do while ("A" <= curr_char & curr_char <= "I"),
                   | ("J" <= curr_char & curr_char <= "R"),
                   | ("S" <= curr_char & curr_char <= "Z"),
                   | ("a" <= curr_char & curr_char <= "i"),
                   | ("j" <= curr_char & curr_char <= "r"),
                   | ("s" <= curr_char & curr_char <= "z"),
                   | ("0" <= curr_char & curr_char <= "9"),
                   | curr_char = "_",
                   | curr_char = "%",
                   | curr_char = "$",
                   | curr_char = "#"
              curr_token = curr_token||curr_char
              Call Get_Char
              End
            If curr_char = "."
              Then
                Call Get_Char
            curr_token = translate(curr_token,,
                                   "abcdefghijklmnopqrstuvwxyz",,
                                   "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
            End
        End
    When curr_char = " "
      Then
        Do
        curr_token_type = "<blanks>"
        Do while (curr_char = " ")
          curr_token = curr_token||curr_char
          Call Get_Char
          End
        End
    When curr_char = "'"
      Then
        Do
        curr_token_type = "<special_char>"
        curr_token = curr_token||curr_char
        Call Get_Char
        End
    When curr_char = "/"
      Then
        Do
        curr_token_type = "<operator>"
        curr_token = curr_token||curr_char
        Call Get_Char
        If curr_char = "*"
          Then
            Do
            curr_token_type = "<comment>"
            curr_token = curr_token||curr_char
            Call Get_Char
            Do forever
              curr_token = curr_token||curr_char
              If curr_char ¬= "*"
                Then
                  Call Get_Char
                Else
                  Do
                  Call Get_Char
                  If curr_char = "/"
                    Then
                      Do
                      curr_token = curr_token||curr_char
                      Call Get_Char
                      Leave
                      End
                  End
              If token_offset > length(curr_stmt)
                Then
                  Do
                  curr_token = curr_token||"*/"
                  Leave
                  End
              End
            End
        End
    When pos(curr_char,"¬<>=&+-/*()") ¬= 0
      Then
        Do
        curr_token_type = "<operator>"
        curr_token = curr_token||curr_char
        save_char = curr_char
        Call Get_Char
        double_operators = "¬<>&/*¬¬"
        double_oprsmates = "===&/*<>"
        If pos(save_char,double_operators) ¬= 0
          Then
            Do i = 1 to length(double_operators)
              If  substr(double_operators,i,1) = save_char,
                & substr(double_oprsmates,i,1) = curr_char,
                Then
                  Do
                  curr_token = curr_token||curr_char
                  Select
                    When curr_token = "¬>"
                      Then
                        curr_token = "<="
                    When curr_token = "¬<"
                      Then
                        curr_token = ">="
                    When curr_token = "&&"
                      Then
                        curr_token = "&"
                    Otherwise
                        nop
                    End
                  Call Get_Char
                  Leave i
                  End
              End
        If pos(save_char,"()") = 0
          Then
            If       ¬(datatype(curr_char,"a"),
              | pos(curr_char,"() &") ¬= 0,
              | token_offset > length(curr_stmt))
              Then
                curr_token_type = "<special_char>"
        End
    Otherwise
        Do
        curr_token_type = "<special_char>"
        curr_token = curr_token||curr_char
        save_char = curr_char
        Call Get_Char
        End
    End
  If token_offset > length(curr_stmt)
    Then
      Do
      next_token_type = "<eos>"
      next_token = ";"
      End
    Else
      Do
      next_token_type = "<?>"
      next_token = "?????"
      End

  If test_mode >= 2 & 0
    Then
      Say "Get_Token      " left(curr_token_type,16) curr_token
  Return 0


/*1*/
/**********************************************************************/
/*** Get_Stmt:                                                      ***/
/***   Subroutine to get one statement from the input stream,       ***/
/***   including handling continuation.                             ***/
/***                                                                ***/
/***   Parameters:                                                  ***/
/***     None.                                                      ***/
/***                                                                ***/
/**********************************************************************/
Get_Stmt:
  curr_stmt = ""
  k = 0
  strip_next_line = 0
  Do forever
    input_line_number = input_line_number + 1
    k = k + 1
    If input_line_number > numlines
      Then
        Leave
    ISREDIT "(THISLINE) = LINE" input_line_number
    If test_mode >= 1
      Then
        Do
        If test_mode >= 2
          Then
            Say copies("-",78)
        Say "Get_Stmt " format(input_line_number,6) strip(thisline,"t")
        End
    Call Put_Line "NOTELINE",thisline
    If strip_next_line
      Then
        thisline = strip(thisline)
      Else
        thisline = strip(thisline,"t")
    strip_next_line = 0
    Select
      When right(thisline,1) = "+"
        Then
          Do
          curr_stmt = curr_stmt||substr(thisline,1,length(thisline)-1)
          strip_next_line = 1
          End
      When right(thisline,1) = "-"
        Then
          curr_stmt = curr_stmt||substr(thisline,1,length(thisline)-1)
      Otherwise
          Do
          curr_stmt = curr_stmt||thisline
          Leave
          End
      End
    End
  first_token = 1
  token_offset = 0
  Call Get_NonBlank_Token
  If curr_token_type = "<label>"
    Then
      Do
      label_list = label_list substr(curr_token,1,length(curr_token)-1)
      Call Put_Token curr_token
      Call Put_Line
      first_token = 0
      Call Get_NonBlank_Token
      End
  first_token = 0
  verb = translate(curr_token)
  Return 0


/*1*/
/**********************************************************************/
/*** Put_Indent:                                                    ***/
/***   Subroutine to put out leading blanks on the current output   ***/
/***   record, so that it indents nicely.                           ***/
/***                                                                ***/
/***   Parameters:                                                  ***/
/***     None.                                                      ***/
/***                                                                ***/
/**********************************************************************/
Put_Indent:
  output_recd = output_recd||copies(" ",,
                                max(0,indent-length(output_recd)))
  Return 0


/*1*/
/**********************************************************************/
/*** Put_Token:                                                     ***/
/***   Subroutine to put out a token or tokens to the current       ***/
/***   output record.                                               ***/
/***                                                                ***/
/***   Parameters:                                                  ***/
/***     1. The token(s) to add to the current output record.       ***/
/***                                                                ***/
/**********************************************************************/
Put_Token:
  output_recd = output_recd||arg(1)
  Return 0


/*1*/
/**********************************************************************/
/*** Put_Line:                                                      ***/
/***   Subroutine to output a record to the output stream.          ***/
/***                                                                ***/
/***   Parameters:                                                  ***/
/***     1. The type of output line.  Values are "", "DATALINE",    ***/
/***        "NOTELINE", and "MSGLINE".  This parameter will be      ***/
/***        used on an PDF edit LINE_BEFORE command.                ***/
/***     2. The line itself.                                        ***/
/***                                                                ***/
/**********************************************************************/
Put_Line:
  If test_mode >= 2
    Then
      Say "Put_Line " format(output_line_number,6) arg(1),
           strip(arg(2),"t")
  If arg(1) ¬= ""
    Then
      Do
      output_line_number = output_line_number + 1
      output_line.output_line_number = arg(2)
      output_line_type.output_line_number = arg(1)
      End
    Else
      Do
      If test_mode >= 2
        Then
          Say "Put_Line " format(output_line_number,6) "**REXX**",
               strip(output_recd,"t")
      If length(output_recd) <= lrecl
        Then
          Do
          output_line_number = output_line_number + 1
          output_line.output_line_number = output_recd
          output_line_type.output_line_number = ""
          output_recd = ""
          End
        Else
          Do
          const_map = ""
          cc = 1
          output_mode = "NORMAL"
          Do while cc <= length(output_recd)
            Select
              When output_mode = "NORMAL"
                Then
                  Do
                  Select
                    When substr(output_recd,cc,1) = """"
                      Then
                        Do
                        output_mode = "QSTRING2"
                        const_map = const_map"1"
                        cc = cc + 1
                        End
                    When substr(output_recd,cc,1) = "'"
                      Then
                        Do
                        output_mode = "QSTRING1"
                        const_map = const_map"1"
                        cc = cc + 1
                        End
                    Otherwise
                        Do
                        const_map = const_map" "
                        cc = cc + 1
                        End
                    End
                  End
              When output_mode = "QSTRING1"
                Then
                  Do
                  Select
                    When substr(output_recd,cc,1) = "'",
                      &  substr(output_recd,cc+1,1) = "'"
                      Then
                        Do
                        const_map = const_map"SS"
                        cc = cc + 2
                        End
                    When substr(output_recd,cc,1) = "'",
                      Then
                        Do
                        output_mode = "NORMAL"
                        const_map = const_map"2"
                        cc = cc + 1
                        End
                    Otherwise
                        Do
                        const_map = const_map"S"
                        cc = cc + 1
                        End
                    End
                End
              When output_mode = "QSTRING2"
                Then
                  Do
                  Select
                    When substr(output_recd,cc,1) = '"',
                      &  substr(output_recd,cc+1,1) = '"'
                      Then
                        Do
                        const_map = const_map"SS"
                        cc = cc + 2
                        End
                    When substr(output_recd,cc,1) = '"',
                      Then
                        Do
                        output_mode = "NORMAL"
                        const_map = const_map"2"
                        cc = cc + 1
                        End
                    Otherwise
                        Do
                        const_map = const_map"S"
                        cc = cc + 1
                        End
                    End
                  End
              End
            End
          Do while length(output_recd) > 0
            If length(output_recd) > lrecl
              Then
                Do
                If substr(const_map,lrecl) = " "
                  Then
                    Do
                    output_line_number = output_line_number + 1
                    output_line.output_line_number,
                          = substr(output_recd,1,71)","
                    output_line_type.output_line_number = ""
                    output_recd = substr(output_recd,72)
                    End
                  Else
                    Do
                    output_line_number = output_line_number + 1
                    output_line.output_line_number,
                          = substr(output_recd,1,72)
                    output_line_type.output_line_number = ""
                    output_recd = substr(output_recd,73)
                    End
                End
              Else
                Do
                output_line_number = output_line_number + 1
                output_line.output_line_number = output_recd
                output_line_type.output_line_number = ""
                output_recd = ""
                End
            End
          End
      End
  Return 0


/*1*/
/**********************************************************************/
/*** Put_Stmt:                                                      ***/
/***   Subroutine to put an entire statement to the output stream.  ***/
/***                                                                ***/
/***   Parameters:                                                  ***/
/***     1. The statement to be output.                             ***/
/***                                                                ***/
/**********************************************************************/
Put_Stmt:
  Call Put_Indent
  Call Put_Token arg(1)
  Call Put_Line
  Return 0


/*1*/
/**********************************************************************/
/*** Put_Msg:                                                       ***/
/***   Subroutine to put a message to the output stream.            ***/
/***                                                                ***/
/***   Parameters:                                                  ***/
/***     1. The message to be output.                               ***/
/***                                                                ***/
/**********************************************************************/
Put_Msg:
  Say arg(1)
  Call Put_Line "MSGLINE",arg(1)
  Return 0


/*1*/
/**********************************************************************/
/*** Check_Concat_Needed:                                           ***/
/***   Subroutine to check to see If REXX needs a concat operator   ***/
/***   where the CLIST did not.                                     ***/
/***                                                                ***/
/***   Parameters:                                                  ***/
/***     None.                                                      ***/
/***                                                                ***/
/**********************************************************************/
Check_Concat_Needed:
  If datatype(right(new_exp,1),"a")
    Then
      new_exp = new_exp||"||"
  Return 0


/*1*/
/**********************************************************************/
/*** Start_Quote_Mode:                                              ***/
/***   Subroutine to start a REXX quoted string if we have not      ***/
/***   already started one.                                         ***/
/***                                                                ***/
/***   Parameters:                                                  ***/
/***     None.                                                      ***/
/***                                                                ***/
/**********************************************************************/
Start_Quote_Mode:
  If quote_mode ¬= "q"
    Then
      Do
      new_exp = new_exp'"'
      quote_mode = "q"
      End
  Return


/*1*/
/**********************************************************************/
/*** End_Quote_Mode:                                                ***/
/***   Subroutine to terminate a REXX quoted string.                ***/
/***                                                                ***/
/***   Parameters:                                                  ***/
/***     None.                                                      ***/
/***                                                                ***/
/**********************************************************************/
End_Quote_Mode:
  If quote_mode ¬= "nq"
    Then
      Do
      blank_count = 0
      Do while length(new_exp) > 0,
        & right(new_exp,1) = " "
        blank_count = blank_count + 1
        new_exp = substr(new_exp,1,length(new_exp)-1)
        End
      If right(new_exp,1) = '"',
        & right(new_exp,2) ¬= '""',
        Then
          new_exp = new_exp||copies(" ",blank_count)'"'
        Else
          new_exp = new_exp'"'copies(" ",blank_count)
      quote_mode = "nq"
      End
  Return

/*1*/
/**********************************************************************/
/*** Help:                                                          ***/
/***   Subroutine to display help text.                             ***/
/***                                                                ***/
/***   Parameters:                                                  ***/
/***     None.                                                      ***/
/***                                                                ***/
/**********************************************************************/
Help:
  Say cmd_name "ISREDIT"
  Say ""
  Say "An ISPF/PDF edit macro to assist with conversion of"
  Say "CLISTs to REXX.  It does not do everything, but is designed"
  Say "to do 90% of the work.  It won't handle, but I hope to"
  Say "add support for in the future:"
  Say ""
  Say "  - abutal (&A&B is translated to ab)"
  Say ""
  Say "You will still have to do some manual touch-up, but I"
  Say "think conversion is now feasable.  You should also"
  Say "review your code to identify those areas where you"
  Say "used several lines of code to implement something REXX"
  Say "provides as a function."
  Say ""
  Say "It won't handle, and I'm not sure how to do the following"
  Say "I wouldn't mind suggestions on how to do these:"
  Say ""
  Say "  - CONTROL END/CAPS/FLUSH/NOFLUSH/MAIN"
  Say "  - ATTN"
  Say "  - ERROR"
  Say "  - GLOBAL"
  Say "  - IF &FOO = THEN +  (nothing on the right of the =)"
  Say "  - Some of the builtin functions and control variables:"
  Say "      &sysscan (always returns 1, setting has no effect)"
  Say "      &maxcc"
  Say "      &sysabncd"
  Say "      &sysabnrc"
  Say "      &syscmdrc"
  Say ""
  Say "It DOES handle CONTROL PROMPT/LIST/CONLIST/SYMLIST/MSG"
  Say "and their inverses.  It will also handle CONTROL"
  Say "ASIS/NOCAPS by ignoring it.  It will not hand CONTROL"
  Say "CAPS."
  Say ""
  Say "GOTO's are translated to SIGNALS, which won't work if"
  Say "the label preceeds the SIGNAL.  You will probably"
  Say "want to manually translate them to LEAVE/ITERATE/SELECT"
  Say "or whatever it was you had in mind."
  Say ""
  Say "REXX statements which are longer than the lrecl are"
  Say "hacked into pieces rather ruthlessly and without warning."
  Say ""
  Say "Untranslateable commands are commented out and prefixed"
  Say "with an !"
  Say ""
  Say "Untranslateable functions and control variables are left"
  Say "alone and prefixed with /*!"
  Say ""
  Say ""
  Say "Syntax:"
  Say ""
  Say "  "cmd_name
  Say ""
  Say ""
  Say "This macro will run under both TSO and CMS."
  Say "                                                                "
  Say "Author:        Chuck Tribolet, TRIBLET at STLMVS1               "
  Return 0

/*1*/
/**********************************************************************/
/*** Append_Stack:                                                  ***/
/***   Subroutine to copy the REXX stack to the PDF editor's        ***/
/***   working copy of the file.                                    ***/
/***                                                                ***/
/***   Parameters:                                                  ***/
/***     None.                                                      ***/
/***                                                                ***/
/**********************************************************************/
Append_Stack: Procedure Expose ISREDIT already_queued,
                             test_mode
  Do while Queued() > already_queued
    Parse Pull Line
    If test_mode >= 1
      Then
        Say "LineAfter" strip(line,"t")
    ISREDIT 'LINE_AFTER .ZLAST = "'line'"'
    End
  Return 0
